.. highlightlang:: c
.. _xref_programmers: 

開発者向け情報
==============

記述言語
--------

lucille のレンダラコア部分はすべて C 言語でコーディングされている. ある程度オブジェクトの概念を取り込んで API と実装をデザインしている. このデザインは glib(GTK で使われている基本ライブラリ)を参考にしてある. 興味のある読者は glib のソースコードを見てみることを薦める(`The GTK+ Project <http://www.gtk.org/>`_).

レンダラコア以外では必要に応じて C 言語以外の言語でコーディングを行っている. たとえば GUI を利用するツールのソースは C++ を利用することもある.

コーディングルール
------------------

lucille では以下のコーディングルールを採用している.

* インデントは 4 文字. タブ文字は使用しない(インデントはスペース).
* 変数名、関数名などはすべて小文字で単語ごとにアンダースコアで区切る
* extern 関数には ``ri_`` のプリフィックスをつける
* struct には ``_t`` のサフィックスをつける
* なるべく行は 80 文字に収まるように調整する
* コメントは基本的に C スタイルのコメント( ``/* ... */`` ) を使う.

コーディングルールに沿ったソースコード記述の例を以下に挙げる.::

  /*
   * Function: ri_list_new
   *
   *   Create a list data structure.
   * 
   * Parameters:
   *
   *   None
   *
   * Returns:
   *
   *   Pointer to the newly created list data. 
   *
   */
  ri_list_t *
  ri_list_new()
  {
      ri_list_t *p;
  
      p = (ri_list_t *)ri_mem_alloc(sizeof(ri_list_t));
  
      p->data = NULL;
      p->next = NULL;
      p->prev = NULL;
  
      return p;
  }

浮動小数点型
------------

レンダラでは浮動小数点データを頻繁に取り扱う. 浮動小数点データを統一して取り扱うために、lucille では、浮動小数点型 ``ri_float_t`` を定義している. 浮動小数点データを扱うコードではこの型を利用すること.  ``ri_float_t`` は double(倍精度浮動小数点) として定義されている.

ベクトル型
----------

lucille のコーディングにおいて浮動小数点型と共に多用されるのが浮動小数点値のベクトル型 ``ri_vector_t`` である. lucille ではこれは 4 要素の double 精度の配列として定義している.

非常に多用されるため, ``vec`` という省略された型名をつかうことができる. これは単純に ``ri_vector_t`` のエイリアスとして定義している.

基本的なデータ型を __m128 などの SIMD 型へのエイリアスとしてしまうと複数の異なる CPU アーキティクチャ環境のサポートが行いづらくなり、ポータビリティが低下してしまうためである.

パフォーマンスが重要な部分ではそこだけ MUDA などで実装してネイティブの SIMD 型を使うようにするポリシーを取っている.

ここで重要になるのはデータのアラインメント問題である. ネイティブの SIMD 変数(__m128 など)は通常メモリ配置位置のアラインメントが特定の値(16 bytes など)に保証されていなければならないが、配列表現のベクトル変数ではその保証は自動では行われない. 演算を高速化するために配列表現のベクトル変数をネイティブの SIMD 型の変数へ変換することがある場合は、アラインを保証したメモリ確保関数 ``ri_mem_alloc_aligned()`` でベクトル変数を確保してアラインを保証しておくようにする.

ベクトル変数の操作
------------------

``src/vector.h`` にベクトル変数の演算を行うマクロもしくはインライン関数が定義されている.

たとえばベクトル変数同士の加算は以下のようになる.::

  ri_vector_t a, b, c;

  ri_vector_add(c, a, b);   /* c = a + b */

ベクトル型の実態は配列であるので、アップデートされる変数をマクロやインライン関数へ渡すときににアドレス(&)を指定する必要はない.

ベクトル操作のマクロも、よく使うものには名前が省略されたものを提供している.::

  vec a, b, c;

  vadd(c, a, b);   /* 上記のコードと処理内容は同一 */


ベクトル型は配列であるので、マクロ形式を使うとコーディングが複雑になる場合は要素ごとに記述するようにもできる. ::

  vec a, b, c, d;

  d[0] = a[0] + b[0] + c[0];
  d[1] = a[1] + b[1] + c[1];
  d[2] = a[2] + b[2] + c[2];



メモリ確保
----------

lucille ではメモリの確保・開放には ``base/memory.h`` で定義されている ``ri_mem_alloc`` と ``ri_mem_free`` を利用する.

アラインの保証されたメモリを確保したい場合は ``ri_mem_alloc_aliged`` を利用する. この関数で確保されたメモリを開放するときは必ず ``ri_mem_free_aligned`` を利用すること. ``free`` や ``ri_mem_free`` を呼んで開放しようとした場合の動作は保証されない.

