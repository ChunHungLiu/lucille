%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "tree.h"
#include "sl2c.h"

#define EXPRLIST_SIZE 1024
#define MAX_BLOCK 128

typedef struct _exprblock_t
{
	node_t *expr;
	int     start;		/* block start */
	int     end;		/* block end   */ 
	int     elsestart;	/* else block start */
	int     elseend;	/* else block end */
	int     indent;
} exprblock_t;

typedef struct _block_t
{
	int              block;
	struct _block_t *prev;
} block_t;

typedef struct _func_body_t
{
	block_t *blocks;
	int currblockdepth;
	exprblock_t exprlist[EXPRLIST_SIZE];
	node_t *formalexprlist[EXPRLIST_SIZE];

	int nexpr;
	int nformalexpr;
	int nscalarexpr;

	char *funcname;
} func_body_t;

block_t *push_block(block_t *block)
{
	block_t *p;

	p = (block_t *)malloc(sizeof(block_t));
	p->prev = block;

	return p;
}

block_t *pop_block(block_t *block)
{
	block_t *p;

	if (block->prev == NULL) {
		return NULL;
	}

	p = block->prev;

	free(block);

	return p;
}

func_body_t f;			/* gloal singleton */

static int vartype;		/* type of variable */

extern int nlines;		/* defined in lexsl.l */
int        get_parsed_line();

void	   yyerror(char *s);

static void write_header();
static void write_body();
static void write_block(int *curr);
static void write_funcarg();
static void write_paraminitializer();

static void init_func_body(char *funcname);


static void
write_header()
{
	fprintf(g_csfp, "/*				\n");
	fprintf(g_csfp, " * Generated by sl2c.		\n");
	fprintf(g_csfp, " */				\n");
	fprintf(g_csfp, "\n");
	fprintf(g_csfp, "#include <stdio.h>\n");
	fprintf(g_csfp, "#include <stdlib.h>\n");
	fprintf(g_csfp, "#include <math.h>\n");
	fprintf(g_csfp, "\n");
	fprintf(g_csfp, "#include \"shader.h\"\n");
	fprintf(g_csfp, "\n");
}

static void
write_body()
{
	int i;
	sym_t *sp;

	fprintf(g_csfp, "DLLEXPORT void\n");
	fprintf(g_csfp, "%s", f.funcname);
	write_funcarg();
	fprintf(g_csfp, "{\n");
			
	for (i = 0; i < f.nformalexpr; i++) {
		write_defvar(f.formalexprlist[i]);
	}

	fprintf(g_csfp, "\n");

	for (i = 0; i < f.nexpr; i++) {
		write_tmpvar(f.exprlist[i].expr);
	}

	fprintf(g_csfp, "\n");

	for (i = 0; i < f.nformalexpr; i++) {
		if (f.formalexprlist[i]->opcode != OPVARDEF) continue;

		sp = (sym_t *)f.formalexprlist[i]->left->left;

		if (sp->type == FLOAT) {
			fprintf(g_csfp, "\tri_param_eval(&%s, param, \"%s\");\n",
				sp->name, sp->name);
		} else {
			fprintf(g_csfp, "\tri_param_eval(&%s, param, \"%s\");\n",
				sp->name, sp->name);
		}
	}

	fprintf(g_csfp, "\n");

	i = 0;
	while (i < f.nexpr) {
		if (f.exprlist[i].expr->opcode == OPFOR   ||
		    f.exprlist[i].expr->opcode == OPWHILE ||
		    f.exprlist[i].expr->opcode == OPIF    ||
		    f.exprlist[i].expr->opcode == OPILLUMINANCE) {
			write_block(&i);
		} else if (f.exprlist[i].expr->type == FLOAT) {
			if (f.exprlist[i].expr->opcode == OPVARDEF &&
			    !f.exprlist[i].expr->right) {
				/* do nothing */
			} else {
				write_scalar_node(f.exprlist[i].expr);
				fprintf(g_csfp, ";\n");
			}
		} else {
			write_node(f.exprlist[i].expr);
		}

		i++;
	}

	fprintf(g_csfp, "}\n");
}

static void
write_block(int *curr)
{
	int i, indent;
	int start, end;
	int elsestart, elseend;

	start     = f.exprlist[*curr].start;
	end       = f.exprlist[*curr].end;
	elsestart = f.exprlist[*curr].elsestart;
	elseend   = f.exprlist[*curr].elseend;

	indent = f.exprlist[*curr].indent;
	set_indent(indent);
	write_scalar_node(f.exprlist[*curr].expr);
	fprintf(g_csfp, "\n");

	i = start;
	while (i <= end) {
		if (f.exprlist[i].expr->opcode == OPFOR   ||
		    f.exprlist[i].expr->opcode == OPWHILE ||
		    f.exprlist[i].expr->opcode == OPIF    ||
		    f.exprlist[i].expr->opcode == OPILLUMINANCE) {
			write_block(&i);
		} else if (f.exprlist[i].expr->type == FLOAT) {
			set_indent(indent + 1);
			write_scalar_node(f.exprlist[i].expr);
			fprintf(g_csfp, ";\n");
		} else {
			set_indent(indent + 1);
			write_node(f.exprlist[i].expr);
		}

		i++;
	}

	set_indent(indent);
	write_indent();
	fprintf(g_csfp, "\t}");

	if (elseend != 0) {
		fprintf(g_csfp, " else {\n");
		i = elsestart;
		while (i <= elseend) {
			if (f.exprlist[i].expr->opcode == OPFOR   ||
			    f.exprlist[i].expr->opcode == OPWHILE ||
			    f.exprlist[i].expr->opcode == OPIF    ||
			    f.exprlist[i].expr->opcode == OPILLUMINANCE) {
				write_block(&i);
			} else if (f.exprlist[i].expr->type == FLOAT) {
				set_indent(indent + 1);
				write_scalar_node(f.exprlist[i].expr);
				fprintf(g_csfp, ";\n");
			} else {
				set_indent(indent + 1);
				write_node(f.exprlist[i].expr);
			}

			i++;
		}

		set_indent(indent);
		write_indent();
		fprintf(g_csfp, "\t}");
	}

	fprintf(g_csfp, "\n");
	set_indent(indent);

	if (elseend == 0) {
		*curr = end;
	} else {
		*curr = elseend;
	}

}

static void
write_funcarg()
{
	fprintf(g_csfp, "(ri_output_t *output, ");
	fprintf(g_csfp, "ri_status_t *status, ");
	fprintf(g_csfp, "ri_parameter_t *param)\n");
}

static void
write_paraminitializer()
{
	int i;
	sym_t *sp;
	char buf[256];

	fprintf(g_csfp, "DLLEXPORT void\n");
	fprintf(g_csfp, "%s_initparam(ri_parameter_t *param)\n", f.funcname);
	fprintf(g_csfp, "{\n");

	for (i = 0; i < f.nformalexpr; i++) {
		write_tmpvar(f.formalexprlist[i]);
	}

	fprintf(g_csfp, "\n");

	for (i = 0; i < f.nformalexpr; i++) {
		if (f.formalexprlist[i]->type == FLOAT) {
			write_scalar_node(f.formalexprlist[i]);
			fprintf(g_csfp, ";\n");
		} else {
			write_node(f.formalexprlist[i]);
		}
	}

	fprintf(g_csfp, "\n");

	for (i = 0; i < f.nformalexpr; i++) {
		if (f.formalexprlist[i]->opcode != OPVARDEF) continue;

		sp = (sym_t *)f.formalexprlist[i]->left->left;

		switch(sp->type) {
		case FLOAT:
			strcpy(buf, "TYPEFLOAT");
			
			break;

		case VECTOR:
		case COLOR:
		case POINT:
			strcpy(buf, "TYPEVECTOR");
			if (!f.formalexprlist[i]->right) {
				/* set default value. */
				fprintf(g_csfp, "\tri_vector_set(%s", sp->name);
				fprintf(g_csfp, ", 0.0, 0.0, 0.0, 1.0);\n");
			}

			break;

		case STRING:
			strcpy(buf, "TYPESTRING");
			if (!f.formalexprlist[i]->right) {
				/* set default value. */
				fprintf(g_csfp, "\t%s = "";\n", sp->name);
			}

			break;

		default:
			strcpy(buf, "TYPEUNKNOWN");
			break;
		}

		if (sp->type == FLOAT) {
			fprintf(g_csfp, "\tri_param_add(param, \"%s\", %s, &%s);\n",
				sp->name, buf, sp->name);
		} else {
			fprintf(g_csfp, "\tri_param_add(param, \"%s\", %s, &%s);\n",
				sp->name, buf, sp->name);
		}

	}
	fprintf(g_csfp, "}\n");
}

void
init_func_body(char *funcname)
{
	static int first = 1;

	if (first) {
		f.blocks = (block_t *)malloc(sizeof(block_t));
		f.blocks->prev = NULL;
		first = 0;

	} else {
		while ((f.blocks = pop_block(f.blocks)) != NULL);

		free(f.funcname);
	}

	f.nexpr          = 0;
	f.nformalexpr    = 0; 
	f.nscalarexpr    = 0;

	f.funcname	 = strdup(funcname);

}

%}

%union {
	char   *string;
	node_t *np;
	double  fval;
}

%token SURFACE
%token <string> IDENTIFIER
%token <fval> NUMBER
%token <string> STRINGCONSTANT
%token VOID FLOAT NORMAL VECTOR COLOR POINT STRING LIGHTSOURCE
%token VARYING UNIFORM
%token ENVIRONMENT
%token TEXTURE
%token RADIANS DEGREES
%token ABS FLOOR CEIL ROUND MIX MOD NOISE STEP SMOOTHSTEP SQRT INVERSESQRT
%token LENGTH
%token SIN ASIN COS ACOS TAN ATAN
%token POW EXP LOG SIGN
%token RANDOM
%token MATH_PI
%token REFRACT
%token OCCLUSION TRACE
%token AMBIENT DIFFUSE SPECULAR TEXTURE ENVIRONMENT
%token PLUSEQ MINUSEQ MULEQ
%token XCOMP YCOMP ZCOMP
%token SETXCOMP SETYCOMP SETZCOMP
%token AREA
%token FOR WHILE IF ELSE
%token ILLUMINANCE
%token OPASSIGN OPVARDEF OPMUL OPDIV OPDOT OPADD OPSUB OPNEG OPFUNC OPFUNCARG
%token OPASSIGNADD OPASSIGNSUB OPASSIGNMUL OPCOND
%token OPPARENT
%token OPLE OPNEQ
%token OPFTOV
%token OPFOR OPFORCOND OPWHILE OPIF OPILLUMINANCE

%right '=' PLUSEQ MINUSEQ MULEQ
%left '<'
%left '+' '-'
%left '*' '/'
%left '.'
%left UMINUS /* unary minus */ TYPECAST

%type <np> assignexpression expression primary triple
%type <np> def_expression def_init
%type <np> procedurecall proc_arguments
%type <np> texture texture_type texture_arguments
%type <np> loop_control relation

%%

/* --- declarations --- */

definitions		: { write_header(); } funclist
;

funclist		: /* empty */
			| funclist function
;

function		: func_head block
			{
				write_paraminitializer();

				fprintf(g_csfp, "\n");
			
				write_body();
			}
;

func_head		: type IDENTIFIER { init_func_body($2); } '(' formals ')'
;

formals			: /* empty */
			| formal_variable_definitions
			| formals ';' formal_variable_definitions
			| formals ';'
;

formal_variable_definitions : typespec formal_def_expressions
;

variable_definitions	: typespec variable_def_expressions
;

typespec		: detail type
;

type			: FLOAT
			{
				vartype = FLOAT;
			}
			| NORMAL
			{
				vartype = NORMAL;
			}
			| VECTOR
			{
				vartype = VECTOR;
			}
			| COLOR
			{
				vartype = COLOR;
			}
			| POINT
			{
				vartype = POINT;
			}
			| STRING
			{
				vartype = STRING;
			}
			| SURFACE
			{
			}
;

detail			: /* empty */
			| VARYING
			{
				/* do nothing */
			}
			| UNIFORM
			{
				/* do nothing */
			}

formal_def_expressions	: def_expression
			{
				f.formalexprlist[f.nformalexpr] = $1;
				f.nformalexpr++;
	
			}
			| formal_def_expressions ',' def_expression
			{
				f.formalexprlist[f.nformalexpr] = $3;
				f.nformalexpr++;
			}
;

variable_def_expressions : def_expression
			{
				f.exprlist[f.nexpr].expr = $1;
				f.nexpr++;
			}
			| variable_def_expressions ',' def_expression
			{
				f.exprlist[f.nexpr].expr = $3;
				f.nexpr++;
			}
;

def_expression	: IDENTIFIER def_init
			{
				var_reg($1, vartype);
				
				$$ = make_node(OPVARDEF,
				     make_leaf($1),
				     $2);
			}
;


def_init		: /* empty */
			{
				$$ = NULL;
			}
			| '=' expression
			{
				$$ = $2;
			}
;

/* --- statements --- */

block			: '{' statements '}'
;	

statements		: /* empty */
			| statements statement
;

statement_list		: statement
			| statement_list statement

statement		: variable_definitions ';'
			| assignexpression ';' 
			{
				f.exprlist[f.nexpr].expr = $1;	
				f.nexpr++;
			}
			| '{' statement_list '}'
			| loop_control statement
			{
				f.blocks = pop_block(f.blocks);
				f.exprlist[f.blocks->block].end = f.nexpr - 1;
			}
			| if_state
			{
				int pos;

				f.blocks = pop_block(f.blocks);
				pos = f.blocks->block;
				f.exprlist[pos].elsestart = 0; 
				f.exprlist[pos].elseend = 0; 
			}
			| if_state ELSE statement
			{
				int pos;

				f.blocks = pop_block(f.blocks);
				pos = f.blocks->block;
				f.exprlist[pos].elseend = f.nexpr - 1;
			}
;

loop_control		: FOR '(' expression ';' relation ';' expression ')'
			{
				f.exprlist[f.nexpr].expr = make_for($3, $5, $7);
				f.exprlist[f.nexpr].start = f.nexpr + 1;
				f.exprlist[f.nexpr].indent = f.currblockdepth;
				f.blocks->block = f.nexpr;
				f.blocks = push_block(f.blocks);
				f.nexpr++;
			}
			| WHILE '(' relation ')'
			{
				f.exprlist[f.nexpr].expr = make_while($3);
				f.exprlist[f.nexpr].start = f.nexpr + 1;
				f.exprlist[f.nexpr].indent = f.currblockdepth;
				f.blocks->block = f.nexpr;
				f.blocks = push_block(f.blocks);
				f.nexpr++;
			}
			| ILLUMINANCE '(' expression ',' expression ',' expression ')'
			{
				f.exprlist[f.nexpr].expr = make_illuminance($3, $5, $7);
				f.exprlist[f.nexpr].start = f.nexpr + 1;
				f.exprlist[f.nexpr].indent = f.currblockdepth;
				f.blocks->block = f.nexpr;
				f.blocks = push_block(f.blocks);
				f.nexpr++;
			}
;

if_state		: if_control statement
			{
				int pos;

				pos = f.blocks->prev->block;
				f.exprlist[pos].end       = f.nexpr - 1;
				f.exprlist[pos].elsestart = f.nexpr;
				f.exprlist[pos].elseend   = 0;
				
			}
;

if_control		: IF '(' relation ')'
			{
				f.exprlist[f.nexpr].expr = make_if($3);
				f.exprlist[f.nexpr].start = f.nexpr + 1;
				f.exprlist[f.nexpr].indent = f.currblockdepth;
				f.blocks->block = f.nexpr;
				f.blocks = push_block(f.blocks);
				f.nexpr++;
			}
;

relation		: expression '<' expression
			{
				$$ = make_node(OPLE, $1, $3);
			}
			| expression OPNEQ expression
			{
				$$ = make_node(OPNEQ, $1, $3);
			}
;

/* --- expressions --- */

expression		: primary
			{
				$$ = $1;
			}
			| expression '+' expression
			{
				$$ = make_node(OPADD, $1, $3);
			}
			| expression '-' expression
			{
				$$ = make_node(OPSUB, $1, $3);
			}
			| expression '*' expression
			{
				$$ = make_node(OPMUL, $1, $3);
			}
			| expression '/' expression
			{
				$$ = make_node(OPDIV, $1, $3);
			}
			| expression '.' expression
			{
				$$ = make_node(OPDOT, $1, $3);
				$$->type = FLOAT;
			}
			| '-' expression %prec UMINUS
			{
				$$ = make_node(OPNEG, $2, NULL);
			}
			| relation '?' expression ':' expression
			{
				$$ = make_cond($1, $3, $5);
				$$->type = FLOAT;
			}
			| '(' expression ')'
			{
				$$ = make_node(OPPARENT, $2, NULL);
			}
			| typecast expression %prec TYPECAST
			{
				$$ = $2;
			}
;

primary			: NUMBER
			{
				$$ = make_constnum($1);
			}
			| MATH_PI
			{
				$$ = make_constnum(3.141593);
			}
			| STRINGCONSTANT
			{
				var_reg($1, vartype);
				$$ = make_conststr($1);
			}
			| IDENTIFIER
			{
				var_reg($1, vartype);
				$$ = make_leaf($1);
			}
			| texture
			{
			}
			| procedurecall
			{
			}
			| assignexpression
			{
			}
			| triple
			{
				$$ = $1;
			}
;

triple			: '(' expression ',' expression ',' expression ')'
			{
				$$ = make_triple($2, $4, $6);
			}

spacetype		: /* empty */
			| STRINGCONSTANT
			{
			}
;

typecast		: COLOR spacetype
;


assignexpression	: IDENTIFIER '=' expression
			{
				var_reg($1, vartype);
				$$ = make_node(OPASSIGN, 
					       make_leaf($1),
					       $3);
			}
			| IDENTIFIER PLUSEQ expression
			{
				var_reg($1, vartype);
				$$ = make_node(OPASSIGNADD, 
					       make_leaf($1),
					       $3);
			}
			| IDENTIFIER MINUSEQ expression
			{
				var_reg($1, vartype);
				$$ = make_node(OPASSIGNSUB, 
					       make_leaf($1),
					       $3);
			}
			| IDENTIFIER MULEQ expression
			{
				var_reg($1, vartype);
				$$ = make_node(OPASSIGNMUL, 
					       make_leaf($1),
					       $3);
			}
;


procedurecall		: RADIANS '(' proc_arguments ')'
			{
				$$ = make_node(RADIANS, NULL, $3);
			}
			| DEGREES '(' proc_arguments ')'
			{
				$$ = make_node(DEGREES, NULL, $3);
			}
			| ABS '(' proc_arguments ')'
			{
				$$ = make_node(ABS, NULL, $3);
			}
			| SIN '(' proc_arguments ')'
			{
				$$ = make_node(SIN, NULL, $3);
			}
			| ASIN '(' proc_arguments ')'
			{
				$$ = make_node(ASIN, NULL, $3);
			}
			| COS '(' proc_arguments ')'
			{
				$$ = make_node(COS, NULL, $3);
			}
			| ACOS '(' proc_arguments ')'
			{
				$$ = make_node(ACOS, NULL, $3);
			}
			| TAN '(' proc_arguments ')'
			{
				$$ = make_node(TAN, NULL, $3);
			}
			| ATAN '(' proc_arguments ')'
			{
				$$ = make_node(ATAN, NULL, $3);
			}
			| POW '(' proc_arguments ')'
			{
				$$ = make_node(POW, NULL, $3);
			}
			| EXP '(' proc_arguments ')'
			{
				$$ = make_node(EXP, NULL, $3);
			}
			| LOG '(' proc_arguments ')'
			{
				$$ = make_node(LOG, NULL, $3);
			}
			| SIGN '(' proc_arguments ')'
			{
				$$ = make_node(SIGN, NULL, $3);
			}
			| RANDOM '(' ')'
			{
				$$ = make_node(RANDOM, NULL, NULL);
			}
			| FLOOR '(' proc_arguments ')'
			{
				$$ = make_node(FLOOR, NULL, $3);
			}
			| CEIL '(' proc_arguments ')'
			{
				$$ = make_node(CEIL, NULL, $3);
			}
			| ROUND '(' proc_arguments ')'
			{
				$$ = make_node(ROUND, NULL, $3);
			}
			| MIX '(' proc_arguments ')'
			{
				$$ = make_node(MIX, NULL, $3);	
				if ($3) {
					$$->type = $3->type;
				}
			}
			| REFRACT '(' proc_arguments ')'
			{
				$$ = make_node(REFRACT, NULL, $3);	
			}
			| MOD '(' proc_arguments ')'
			{
				$$ = make_node(MOD, NULL, $3);	
			}
			| NOISE '(' proc_arguments ')'
			{
				$$ = make_node(NOISE, NULL, $3);	
				$$->type = FLOAT;
			}
			| LENGTH '(' proc_arguments ')'
			{
				$$ = make_node(LENGTH, NULL, $3);	
				$$->type = FLOAT;
			}
			| AMBIENT '(' proc_arguments ')'
			{
				$$ = make_node(AMBIENT, NULL, $3);	
			}
			| DIFFUSE '(' proc_arguments ')'
			{
				$$ = make_node(DIFFUSE, NULL, $3);	
			}
			| SPECULAR '(' proc_arguments ')'
			{
				$$ = make_node(SPECULAR, NULL, $3);	
			}
			| ENVIRONMENT '(' proc_arguments ')'
			{
				$$ = make_node(ENVIRONMENT, NULL, $3);	
			}
			//| TEXTURE '(' proc_arguments ')'
			//{
			//	$$ = make_node(TEXTURE, NULL, $3);	
			//	$$->type = COLOR;
			//}
			| OCCLUSION '(' proc_arguments ')'
			{
				$$ = make_node(OCCLUSION, NULL, $3);	
				$$->type = FLOAT;
			}
			| TRACE '(' proc_arguments ')'
			{
				$$ = make_node(TRACE, NULL, $3);	
			}
			| STEP '(' proc_arguments ')'
			{
				$$ = make_node(STEP, NULL, $3);	
				$$->type = FLOAT;
			}
			| SMOOTHSTEP '(' proc_arguments ')'
			{
				$$ = make_node(SMOOTHSTEP, NULL, $3);	
				$$->type = FLOAT;
			}
			| SQRT '(' proc_arguments ')'
			{
				$$ = make_node(SQRT, NULL, $3);
			}
			| INVERSESQRT '(' proc_arguments ')'
			{
				$$ = make_node(INVERSESQRT, NULL, $3);
			}
			| XCOMP '(' proc_arguments ')'
			{
				$$ = make_node(XCOMP, NULL, $3);
				$$->type = FLOAT;
			}
			| YCOMP '(' proc_arguments ')'
			{
				$$ = make_node(YCOMP, NULL, $3);
				$$->type = FLOAT;
			}
			| ZCOMP '(' proc_arguments ')'
			{
				$$ = make_node(ZCOMP, NULL, $3);
				$$->type = FLOAT;
			}
			| SETXCOMP '(' proc_arguments ')'
			{
				$$ = make_node(SETXCOMP, NULL, $3);
				$$->type = VOID;
			}
			| SETYCOMP '(' proc_arguments ')'
			{
				$$ = make_node(SETYCOMP, NULL, $3);
				$$->type = VOID;
			}
			| SETZCOMP '(' proc_arguments ')'
			{
				$$ = make_node(SETZCOMP, NULL, $3);
				$$->type = VOID;
			}
			| AREA '(' proc_arguments ')'
			{
				$$ = make_node(AREA, NULL, $3);
				$$->type = FLOAT;
			}
			| IDENTIFIER '(' proc_arguments ')'
			{
				var_reg($1, VECTOR);
				$$ = make_node(OPFUNC,
					       make_leaf($1),
					       $3);
			}
;

proc_arguments		: /* empty */
			{
				$$ = NULL;
			}
			| expression
			{
				$$ = make_node(OPFUNCARG,
					       $1,
					       NULL);
				//$$ = $1;
			}
			| expression ',' proc_arguments
			{
				$$ = make_node(OPFUNCARG,
					       $1,
					       $3);
			}
;

texture			: texture_type
			  '(' texture_arguments ')'
			{
				$$ = make_node(TEXTURE,
					       $1,
					       $3);
				//$$->type = COLOR;

			}
;

texture_type		: ENVIRONMENT
			{
				char *tex = "environment";
				var_reg(tex, COLOR);

				$$ = make_leaf(tex);
			}
			| TEXTURE
			{
				char *tex = "texture";
				var_reg(tex, COLOR);

				$$ = make_leaf(tex);
			}
;

texture_arguments	: expression
			{
				$$ = make_node(OPFUNCARG,
					       $1,
					       NULL);
			}
			| expression ',' texture_arguments
			{
				$$ = make_node(OPFUNCARG,
					       $1,
					       $3);
			}
;

%%

#if 0
int
main(int argc, char **argv)
{
	extern FILE *yyin;
	extern int yydebug;

	if (argc < 2) {
		printf("usage: %s file.sl\n", argv[0]);
		exit(-1);
	}

	yyin = fopen(argv[1], "r");

	//yydebug = 1;

	yyparse();

	return 0;
}
#endif

int
get_parsed_line()
{
	return nlines;
}

void
yyerror(char *s)
{
	fprintf(stderr, "Parse error: %s at line %d\n", s, nlines);
}

